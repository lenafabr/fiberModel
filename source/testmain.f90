PROGRAM MAIN
  IMPLICIT NONE

  !CALL TESTROTATECHAIN
  !CALL TESTHELIXMCSTEP
  !CALL TESTDATABASE
    CALL TESTENERGY
  !  CALL TESTSETUP
CONTAINS
  SUBROUTINE TESTROTATECHAIN
    ! Check chain rotation and make sure energy does not change
    USE KEYS
    USE DRIVERS
    USE HELIXUTILS
    USE CHAINUTILS
    USE QUATUTILS
    USE ENERGYUTILS
    IMPLICIT NONE
    TYPE(CHAIN), TARGET :: WLC
    TYPE(CHAIN), POINTER :: CHAINP
    DOUBLE PRECISION :: VEC(3)
    TYPE(QUATERNION) :: QROT

    CALL READKEY

    CHAINP=>WLC
    CALL SETUPDRIVER(CHAINP)

    CALL HELENERGYGRAD(CHAINP)
    PRINT*, 'ENERGY: ', CHAINP%ENERGY
    print*, chainp%energyparts

    !VEC = (/1D0,2D0,3D0/); VEC = VEC/SQRT(DOT_PRODUCT(VEC,VEC))
    VEC = (/-0.92656752139482823,  0.34862232657409375,      -0.14119171969457181/)
    VEC = VEC/SQRT(DOT_PRODUCT(VEC,VEC))
    QROT = ROTQUAT(2.1407112306966312D0,VEC)
    CALL ROTATECHAIN(CHAINP,QROT)
    CALL HELENERGYGRAD(CHAINP)
    PRINT*, 'ENERGY: ', CHAINP%ENERGY
    print*, chainp%energyparts
  END SUBROUTINE TESTROTATECHAIN

  SUBROUTINE TESTHELIXMCSTEP
    ! test MC steps for helical coordinates
    USE BASINHOPUTILS
    USE CHAINUTILS
    USE KEYS
    USE DRIVERS
    IMPLICIT NONE
    TYPE(CHAIN), TARGET :: WLC
    TYPE(CHAIN), POINTER :: CHAINP

    CALL READKEY

    CHAINP=>WLC
    CALL SETUPDRIVER(CHAINP)

    PRINT*, CHAINP%VEC(1:6)
    CALL HELIXMCSTEP(CHAINP,2,1D0,0.1D0,0.1D0)
    PRINT*, CHAINP%VEC(1:6)

    CALL CLEANUPDRIVER(CHAINP)
  END SUBROUTINE TESTHELIXMCSTEP

  SUBROUTINE TESTDATABASE
    ! test database parsing
    USE KEYS
    USE CHAINUTILS
    USE DATABASEUTILS
    USE HELIXUTILS
    USE ENERGYUTILS
    IMPLICIT NONE

    TYPE(DATACHAIN), TARGET :: DB
    TYPE(DATACHAIN), POINTER :: DBPT
    INTEGER :: EXTRAINT
    DBPT=>DB

    CALL READKEY

    CALL SETUPDATABASE(DBPT,NCONFIGSAVE)
    CALL READDATABASE(DBPT,DATAFILE)
    CALL DUMPDATABASE(DBPT,NEWDATAFILE)
    CALL CLEANUPDATABASE(DBPT)
  END SUBROUTINE TESTDATABASE
  
  SUBROUTINE TESTENERGY
    ! test energy and gradient for the chain
    USE KEYS
    USE CHAINUTILS
    USE HELIXUTILS
    USE DRIVERS
    USE ENERGYUTILS, ONLY : HELENERGYGRAD, helenergytest

    IMPLICIT NONE
    TYPE(CHAIN), TARGET :: WLC, wlc2
    TYPE(CHAIN), POINTER :: CHAINP, chainp2
    INTEGER :: I
    DOUBLE PRECISION :: ENERGY
    DOUBLE PRECISION, ALLOCATABLE :: GRADSAVE(:)
    DOUBLE PRECISION, PARAMETER :: TINY = 1D-12
    LOGICAL :: GIMBAL, BEADHIT

    CHAINP=> WLC; CHAINP2=>WLC2

    CALL READKEY    
    CALL SETUPDRIVER(CHAINP)
   
!    CALL OUTPUTCHAIN(CHAINP, OUTFILE)
!    CALL OUTPUTREPLIC(CHAINP,30,REPLICFILE)    

    !CALL HELCRDFROMFILE(CHAINP,'badcrd.out')

    ! PRINT*, 'TESTX1:'
    ! DO I = 1,CHAINP%NCRD
    !    PRINT*, I, CHAINP%VEC(I)
    ! ENDDO

    ALLOCATE(GRADSAVE(CHAINP%NCRD))

    helenergytest = .true.
    CALL HELENERGYGRAD(CHAINP)
    helenergytest = .false.
    ENERGY = CHAINP%ENERGY; GRADSAVE = CHAINP%GRAD
    PRINT*, 'ENERGY: ', CHAINP%ENERGY
    PRINT*, 'ENERGY PARTS: ', chainp%ENERGYPARTS
    CALL CHECKGIMBAL(CHAINP,GIMBAL,BEADHIT)
    PRINT*, 'GIMBAL, BEADHIT?:', GIMBAL, BEADHIT

    DO I = 76,78
       CHAINP%VEC(I) = CHAINP%VEC(I) + TINY
       CALL HELENERGYGRAD(CHAINP)

       PRINT*, I, (CHAINP%ENERGY-ENERGY)/TINY, GRADSAVE(I)
       CHAINP%VEC(I) = CHAINP%VEC(I) - TINY
    ENDDO

    DEALLOCATE(GRADSAVE)
    CALL CLEANUPDRIVER(CHAINP)
    !CALL CLEANUPDRIVER(CHAINP2)
  END SUBROUTINE TESTENERGY

  SUBROUTINE TESTSETUP
    ! test various setup subroutines
    USE KEYS
    USE CHAINUTILS
    USE HELIXUTILS
    USE QUATUTILS
    USE INPUTSTRUCTS
    IMPLICIT NONE

    TYPE(CHAIN), TARGET :: WLC, WLC2
    TYPE(CHAIN), POINTER :: CHAINP, CHAINP2
    TYPE(BEND), POINTER :: BP, BP2
    TYPE(QUATERNION) :: QREL, QP
    DOUBLE PRECISION :: RELEULER(3), ZAX(3)
    INTEGER :: B, i

    CHAINP => WLC; CHAINP2=>WLC2

    CALL READKEY     

    CALL READOUTFILE(CHAINP,'test.replic.out',2)
    CALL GETHELIXREP(CHAINP)
    ! ZAX = CHAINP%BEADS(17,:)-CHAINP%BEADS(16,:)
    ! PRINT*, ZAX/SQRT(DOT_PRODUCT(zax,zax))
    ! ZAX = QUAT2PT(CHAINP%BEADQ(16)*PTQUAT((/0D0,0D0,1D0/))/CHAINP%BEADQ(16))
    ! PRINT*, ZAX

   !CALL CREATECHAIN(chainp)
   !CALL MAKEHELIX(CHAINP,HELH,HELT,HELR,(/HELA,HELB,HELG/))
   !PRINT*, 'Chain coords:'
   !PRINT*, CHAINP%VEC(1:6)
   !CALL GETHELIXREP(CHAINP2)
   ! PRINT*, CHAINP%VEC(1:10)      
   ! do i = chainp%bendind(1)+1,chainp%bendind(2)
   !    print '(i3,7G15.5)', i-chainp%bendind(1), chainp%beads(i,:), chainp%beadq(i)
   ! enddo

   ! stop 1
    ! CALL FROMHELIXREP(CHAINP)
    ! CALL GETHELIXREP(CHAINP)

    ! PRINT*, CHAINP%VEC(1:10)
    ! CALL FROMHELIXREP(CHAINP)
    ! check relative twist at end
    ! BP => CHAINP%BENDS(1)
    ! BP2 => CHAINP%BENDS(2)

    ! QREL = INVQUAT(CHAINP%BEADQ(CHAINP%BENDIND(2)-1))*(BP2%ORIENT*BP2%TM)
    ! CALL QUAT2EULER(QREL,RELEULER)
    ! PRINT*, 'RELATIVE EULER:', RELEULER
    ! QREL = INVQUAT(CHAINP%BEADQ(CHAINP%BENDIND(2)-2))*CHAINP%BEADQ(CHAINP%BENDIND(2)-1)
    ! CALL QUAT2EULER(QREL,RELEULER)
    ! PRINT*, 'RELATIVE EULER:', RELEULER

    CALL OUTPUTCHAIN(CHAINP,'test2.out')   

    ! CALL CREATECHAIN(CHAINP2,30)
    ! CHAINP2%VEC = CHAINP%VEC
    ! CALL FROMHELIXREP(CHAINP2)

    ! CALL OUTPUTCHAIN(CHAINP2,'test.replic.out')

!    CALL MAKEBARECHAIN(CHAINP,20,2,10)    
    CALL CLEANUPCHAIN(CHAINP)
  END SUBROUTINE TESTSETUP

END PROGRAM MAIN
